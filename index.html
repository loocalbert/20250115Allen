    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <title>AI Object Tracker</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
        }
        .container {
            text-align: center;
            background-color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            max-width: 100%;
            width: 100%;
            margin: 10px;
            box-sizing: border-box;
        }
        .title-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .title-rose {
            height: 1em; /* This will match the height of "Cam" */
            width: auto;
            object-fit: contain;
        }
        #cameraFeed {
            width: 100%;
            max-width: 100%;
            height: auto;
            border: 2px solid #333;
            border-radius: 5px;
            margin: 10px 0;
        }
        button {
            min-height: 44px; 
            min-width: 44px;
            padding: 12px 24px;
            font-size: 16px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        #cameraSelect, #apiKeyInput, #languageSelect {
            -webkit-appearance: none;
            font-size: 16px; 
            padding: 12px;
            margin: 8px 0;
        }
        #analysisResult, #objectMemory {
            margin-top: 20px;
            padding: 10px;
            background-color: #e9f7ef;
            border-radius: 5px;
            font-style: italic;
        }
        #objectMemory {
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
        }
        .memory-item {
            flex-direction: column;
            align-items: flex-start;
        }
        .memory-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
            width: 100%;
        }
        .memory-note {
            flex: 1;
            padding: 5px;
            font-size: 14px;
            border: 1px solid #ddd;
            border-radius: 3px;
        }
        .captured-photo {
            width: 100%;
            max-width: 200px;
            margin-top: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .clear-item-button {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 12px;
            min-height: 44px;
            min-width: 44px;
        }
        .clear-item-button:hover {
            background-color: #c82333;
        }
        .edit-button {
            background-color: #ffc107;
            color: black;
            border: none;
            border-radius: 3px;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 20px;
            margin-right: 5px;
            min-height: 44px;
            min-width: 44px;
        }
        .edit-button:hover {
            background-color: #e0a800;
        }
        .edit-button::before {
            content: '✎';
            font-size: 20px;
            display: inline-block;
            line-height: 1;
        }
        .mic-button, .camera-button {
            min-height: 44px;
            min-width: 44px;
            padding: 8px 16px;
        }
        .mic-button {
            background-color: #e0f7fa;
            color: black;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
            padding: 0; 
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .mic-button::before {
            content: '🎤';
            font-size: 20px;
            display: inline-block;
            line-height: 1;
        }
        .mic-button:hover {
            background-color: #cccccc;
        }
        .mic-button.recording {
            background-color: #dc3545;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .camera-button {
            background-color: #77dd77;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 3px 8px;
            cursor: pointer;
            font-size: 12px;
            margin-right: 5px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .camera-button::before {
            content: '📷';
            font-size: 20px;
            display: inline-block;
            line-height: 1;
        }
        .camera-button:hover {
            background-color: #5cb85c;
        }
        .delete-photo-button {
            background-color: #ff4444;
            color: white;
            border: none;
            border-radius: 3px;
            padding: 12px 16px;
            cursor: pointer;
            font-size: 12px;
            margin-left: 5px;
            display: flex;
            align-items: center;
            gap: 5px; 
            min-height: 44px;
            min-width: 44px;
        }
        .delete-photo-button:hover {
            background-color: #cc0000;
        }
        .photo-container {
            position: relative;
            display: inline-block;
            margin-top: 10px;
        }
        .upload-button {
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 10px 20px;
            cursor: pointer;
            margin: 10px 0;
            font-size: 14px;
            display: inline-block; 
        }
        .upload-button:hover {
            background-color: #0056b3;
        }
        #fileInput {
          display: none;
        }
        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .save-config-button {
            background-color: #007bff;
            margin: 15px 0;
            width: auto;
        }
        .custom-object-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            width: 100%;
            max-width: 100%;
        }
        #customObjectInput {
            flex: 1;
            width: 100%;
            max-width: 100%;
            margin: 10px 0;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        .filter-input-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            width: 100%;
            max-width: 100%;
        }
        .filter-input {
            flex: 1;
            width: 100%;
            max-width: 100%;
            margin: 10px 0;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        .filter-label {
            font-style: normal;
            margin-bottom: 5px;
            margin-top: 20px;
        }
        .memory-item-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 5px;
        }
        .memory-item-buttons button {
            padding: 5px 10px;
            font-size: 12px;
            border-radius: 4px;
            border: none;
            background-color: #ffff00;
            cursor: pointer;
            min-height: auto;
            min-width: auto;
            color: black;
        }
        .memory-item-buttons button:hover {
            background-color: #e0e0e0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="title-container">
            <img src="/a/bf8c50d1-fef0-4f67-80c8-d536201a1eda" alt="A vibrant red rose with detailed petals" class="title-rose">
            <h1 id="title">AI Object Tracker</h1>
        </div>
        <button id="saveConfigButtonTop" class="save-config-button">Save Configuration to File</button>
        <input type="text" id="apiKeyInput" placeholder="Enter your Gemini API key">
        <select id="cameraSelect">
            <option value>Loading cameras...</option>
        </select>
        <select id="languageSelect">
            <option value="en">English</option>
            <option value="es">Espa&#xf1;ol</option>
            <option value="fr">Fran&#xe7;ais</option>
            <option value="de">Deutsch</option>
            <option value="it">Italiano</option>
            <option value="pt">Portugu&#xea;s</option>
            <option value="ja">&#x65e5;&#x672c;&#x8a9e;</option>
            <option value="ko">&#xd55c;&#xad6d;&#xc5b4;</option>
            <option value="zh-TW">&#x4e2d;&#x6587;&#xff08;&#x7e41;&#x9ad4;&#xff09;</option>
        </select>
        <br>
        <video id="cameraFeed" autoplay playsinline></video>
        <br>
        <button id="captureButton">Capture Photo and Analyze</button>
        <div class="spinner" id="spinner"></div>
        <div id="analysisResult"></div>
        <h2 class="filter-label" id="filter-label">Search Objects</h2>
        <div class="filter-input-container">
          <input type="text" id="filterInput" class="filter-input" placeholder="Filter remembered objects...">
          <button class="mic-button" id="filterMic"></button>
       </div>
       <h2 id="remembered-objects">Remembered Objects</h2>
        <div class="custom-object-container">
            <input type="text" id="customObjectInput" placeholder="Type a custom object to remember...">
            <button class="mic-button" id="customObjectMic"></button>
            <button id="addObjectButton" class="add-object-button">Add Object</button>
        </div>
        <div id="objectMemory"></div>
        <button id="saveConfigButtonBottom" class="save-config-button">Save Configuration to File</button>
        <input type="file" id="fileInput" accept=".json" style="display: none;">
        <button id="uploadConfigButton" class="upload-button">Upload Configuration from File</button>
        <div id="uploadMessage" style="display:none; margin-top: 10px; font-style: italic; color: green;">Finished Uploading</div>
    </div>

    <script>const cameraFeed = document.getElementById('cameraFeed');
const captureButton = document.getElementById('captureButton');
const cameraSelect = document.getElementById('cameraSelect');
const analysisResult = document.getElementById('analysisResult');
const objectMemory = document.getElementById('objectMemory');
const spinner = document.getElementById('spinner');
const apiKeyInput = document.getElementById('apiKeyInput');
const languageSelect = document.getElementById('languageSelect');
const uploadMessage = document.getElementById('uploadMessage');
const filterInput = document.getElementById('filterInput');
let currentStream;
let capturedImage;
let rememberedObjects = JSON.parse(localStorage.getItem('rememberedObjects') || '[]').map(obj => typeof obj === 'string' ? {} : obj);
const objectTranslations = {
  "detected": {
    en: "detected",
    es: "detectado",
    fr: "détecté",
    de: "erkannt",
    it: "rilevato",
    pt: "detectado",
    ja: "検出された",
    ko: "감지된",
    "zh-TW": "檢測到"
  }
};
const translations = {
  en: {
    title: "Smart Object Keeper",
    apiKeyPlaceholder: "Enter your Gemini API key",
    captureButton: "Capture Photo and Analyze",
    rememberedObjects: "Remembered Objects",
    analyzing: "Capturing photo and analyzing...",
    apiKeyError: "Please enter your Gemini API key.",
    cameraError: "Unable to access the selected camera. Please try another or check your permissions.",
    initError: "Unable to access any camera. Please check your device and permissions.",
    saveConfigButton: "Save Configuration to File",
    deleteConfirm: "Are you sure you want to delete this item?",
    editPrompt: "Edit object:",
    customObjectPlaceholder: "Type a custom object to remember...",
    addCustomObject: "Add Object",
    microphoneNotSupported: "Speech recognition is not supported in this browser.",
    objectAdded: 'Object added successfully!',
    deletePhotoConfirm: "Are you sure you want to delete this photo?",
    uploadConfigButton: "Upload Configuration from File",
    uploadInstruction: "Please upload a JSON file containing your object configurations.",
    filterPlaceholder:  "Filter remembered objects...",
    uploadFinished: "Finished Uploading",
    filterLabel: "Search Objects"
  },
  es: {
    title: "Administrador Inteligente de Objetos",
    apiKeyPlaceholder: "Ingrese su clave API de Gemini",
    captureButton: "Capturar Foto y Analizar",
    rememberedObjects: "Objetos Recordados",
    analyzing: "Capturando foto y analizando...",
    apiKeyError: "Por favor ingrese su clave API de Gemini.",
    cameraError: "No se puede acceder a la cámara seleccionada. Intente con otra o verifique sus permisos.",
    initError: "No se puede acceder a ninguna cámara. Verifique su dispositivo y permisos.",
    saveConfigButton: "Guardar Configuración en Archivo",
    deleteConfirm: "¿Está seguro de que desea eliminar este elemento?",
    editPrompt: "Editar objeto:",
    customObjectPlaceholder: "Escriba un objeto personalizado para recordar...",
    addCustomObject: "Agregar Objeto",
    microphoneNotSupported: "El reconocimiento de voz no está soportado en este navegador.",
    objectAdded: '¡Objeto agregado exitosamente!',
    deletePhotoConfirm: "¿Está seguro de que desea eliminar esta foto?",
    uploadConfigButton: "Cargar Configuración desde Archivo",
    uploadInstruction: "Por favor carga un archivo JSON que contenga tus configuraciones de objetos.",
    filterPlaceholder:  "Filtrar objetos recordados...",
    uploadFinished: "Carga Finalizada",
    filterLabel: "Buscar Objetos"
  },
  fr: {
    title: "Gestionnaire Intelligent d'Objets",
    apiKeyPlaceholder: "Entrez votre clé API Gemini",
    captureButton: "Capturer et Analyser la Photo",
    rememberedObjects: "Objets Mémorisés",
    analyzing: "Capture et analyse de la photo...",
    apiKeyError: "Veuillez entrer votre clé API Gemini.",
    cameraError: "Impossible d'accéder à la caméra sélectionnée. Veuillez en essayer une autre ou vérifier vos permissions.",
    initError: "Impossible d'accéder à une caméra. Veuillez vérifier votre appareil et vos permissions.",
    saveConfigButton: "Enregistrer la Configuration",
    deleteConfirm: "Êtes-vous sûr de vouloir supprimer cet élément?",
    editPrompt: "Modifier l'objet:",
    customObjectPlaceholder: "Tapez un objet personnalisé à mémoriser...",
    addCustomObject: "Ajouter l'Objet",
    microphoneNotSupported: "La reconnaissance vocale n'est pas prise en charge dans ce navigateur.",
    objectAdded: 'Objet ajouté avec succès!',
    deletePhotoConfirm: "Êtes-vous sûr de vouloir supprimer cette photo?",
    uploadConfigButton: "Télécharger la Configuration depuis un Fichier",
    uploadInstruction: "Veuillez télécharger un fichier JSON contenant vos configurations d'objets.",
    filterPlaceholder:  "Filtrer les objets mémorisés...",
    uploadFinished: "Téléchargement Terminé",
    filterLabel: "Rechercher les Objets"
  },
  ko: {
    "title": "스마트 오브젝트 키퍼",
    "apiKeyPlaceholder": "Gemini API 키를 입력하세요",
    "captureButton": "사진 캡처 및 분석",
    "rememberedObjects": "기억된 객체",
    "analyzing": "사진을 캡처하고 분석 중...",
    "apiKeyError": "Gemini API 키를 입력해주세요.",
    "cameraError": "선택한 카메라에 접근할 수 없습니다. 다른 카메라인을 시도하거나 권한을 확인하세요.",
    "initError": "사용 가능한 카메라가 없습니다. 기기와 권한을 확인하세요.",
    "saveConfigButton": "설정을 파일로 저장",
    "deleteConfirm": "이 항목을 삭제하시겠습니까?",
    "editPrompt": "객체 편집:",
    "customObjectPlaceholder": "기억할 사용자 정의 객체를 입력하세요...",
    "addCustomObject": "객체 추가",
    "microphoneNotSupported": "이 브라우저는 음성 인식을 지원하지 않습니다.",
    "objectAdded": "객체가 추가되었습니다!",
    "deletePhotoConfirm": "이 사진을 삭제하시겠습니까?",
    "uploadConfigButton": "파일에서 설정 업로드",
    "uploadInstruction": "객체 설정을 포함하는 JSON 파일을 업로드하세요.",
    filterPlaceholder:  "기억된 객체를 필터링...",
    "uploadFinished": "업로드 완료",
    filterLabel: "객체 검색"
  },
  de: {
     "title": "Intelligenter Objekthalter",
    "apiKeyPlaceholder": "Geben Sie Ihren Gemini-API-Schlüssel ein",
    "captureButton": "Foto aufnehmen und analysieren",
    "rememberedObjects": "Gespeicherte Objekte",
    "analyzing": "Foto wird aufgenommen und analysiert...",
    "apiKeyError": "Bitte geben Sie Ihren Gemini-API-Schlüssel ein.",
    "cameraError": "Auf die ausgewählte Kamera kann nicht zugegriffen werden. Versuchen Sie es mit einer anderen oder überprüfen Sie Ihre Berechtigungen.",
    "initError": "Es kann auf keine Kamera zugegriffen werden. Überprüfen Sie Ihr Gerät und Ihre Berechtigungen.",
    "saveConfigButton": "Einstellungen in Datei speichern",
    "deleteConfirm": "Sind Sie sicher, dass Sie dieses Element löschen möchten?",
    "editPrompt": "Objekt bearbeiten:",
    "customObjectPlaceholder": "Geben Sie ein benutzerdefiniertes Objekt ein, das gespeichert werden soll...",
    "addCustomObject": "Objekt hinzufügen",
    "microphoneNotSupported": "Spracherkennung wird in diesem Browser nicht unterstützt.",
    "objectAdded": "Objekt erfolgreich hinzugefügt!",
    "deletePhotoConfirm": "Sind Sie sicher, dass Sie dieses Foto löschen möchten?",
    "uploadConfigButton": "Einstellungen aus Datei hochladen",
    "uploadInstruction": "Bitte laden Sie eine JSON-Datei mit Ihren Objektkonfigurationen hoch.",
    filterPlaceholder: "Gespeicherte Objekte filtern...",
    "uploadFinished": "Upload abgeschlossen",
    filterLabel: "Objekte suchen"
  },
  it: {
    "title": "Gestore Intelligente di Oggetti",
    "apiKeyPlaceholder": "Inserisci la tua chiave API di Gemini",
    "captureButton": "Cattura Foto e Analizza",
    "rememberedObjects": "Oggetti Salvati",
    "analyzing": "Catturando foto e analizzando...",
    "apiKeyError": "Per favore inserisci la tua chiave API di Gemini.",
    "cameraError": "Impossibile accedere alla fotocamera selezionata. Prova con un'altra o verifica i permessi.",
    "initError": "Impossibile accedere a nessuna fotocamera. Controlla il tuo dispositivo e i permessi.",
    "saveConfigButton": "Salva Configurazione in File",
    "deleteConfirm": "Sei sicuro di voler eliminare questo elemento?",
    "editPrompt": "Modifica oggetto:",
    "customObjectPlaceholder": "Scrivi un oggetto personalizzato da salvare...",
    "addCustomObject": "Aggiungi Oggetto",
    "microphoneNotSupported": "Il riconoscimento vocale non è supportato in questo browser.",
    "objectAdded": "Oggetto aggiunto con successo!",
    "deletePhotoConfirm": "Sei sicuro di voler eliminare questa foto?",
    "uploadConfigButton": "Carica Configurazione da File",
    "uploadInstruction": "Carica un file JSON che contenga le tue configurazioni degli oggetti.",
    filterPlaceholder: "Filtra gli oggetti memorizzati...",
    "uploadFinished": "Caricamento completato",
    filterLabel: "Cerca oggetti"
  },
  pt: {
     "title": "Guardião Inteligente de Objetos",
    "apiKeyPlaceholder": "Insira sua chave API do Gemini",
    "captureButton": "Capturar Foto e Analisar",
    "rememberedObjects": "Objetos Salvos",
    "analyzing": "Capturando foto e analisando...",
    "apiKeyError": "Por favor, insira sua chave API do Gemini.",
    "cameraError": "Não é possível acessar a câmera selecionada. Tente outra ou verifique suas permissões.",
    "initError": "Não é possível acessar nenhuma câmera. Verifique seu dispositivo e permissões.",
    "saveConfigButton": "Salvar Configuração em Arquivo",
    "deleteConfirm": "Tem certeza de que deseja excluir este item?",
    "editPrompt": "Editar objeto:",
    "customObjectPlaceholder": "Digite um objeto personalizado para salvar...",
    "addCustomObject": "Adicionar Objeto",
    "microphoneNotSupported": "O reconhecimento de voz não é suportado neste navegador.",
    "objectAdded": "Objeto adicionado com sucesso!",
    "deletePhotoConfirm": "Tem certeza de que deseja excluir esta foto?",
    "uploadConfigButton": "Carregar Configuração de Arquivo",
    "uploadInstruction": "Por favor, carregue um arquivo JSON contendo suas configurações de objetos.",
    filterPlaceholder: "Filtrar objetos lembrados...",
    "uploadFinished": "Carregamento concluído",
    filterLabel: "Procurar objetos"
  },
  'ja': {
    title: "スマートオブジェクトキーパー",
    apiKeyPlaceholder: "Gemini APIキーを入力してください",
    captureButton: "写真を撮って解析する",
    rememberedObjects: "記憶されたオブジェクト",
    analyzing: "写真を撮って解析中...",
    apiKeyError: "Gemini APIキーを入力してください。",
    cameraError: "選択したカメラにアクセスできません。他のカメラインを試すか、権限を確認してください。",
    initError: "どのカメラにもアクセスできません。デバイスと権限を確認してください。",
    saveConfigButton: "設定ファイルを保存する",
    deleteConfirm: "この項目を削除してもよろしいですか？",
    editPrompt: "オブジェクトを編集：",
    customObjectPlaceholder: "記憶するカスタムオブジェクトを入力してください...",
    addCustomObject: "オブジェクトを追加する",
    microphoneNotSupported: "このブラウザは音声認識をサポートしていません。",
    objectAdded: "オブジェクトが追加されました！",
    deletePhotoConfirm: "この写真を削除してもよろしいですか？",
    uploadConfigButton: "ファイルから設定をアップロードする",
    uploadInstruction: "オブジェクト設定を含むJSONファイルをアップロードしてください。",
    filterPlaceholder: "記憶されたオブジェクトをフィルタ...",
    uploadFinished: "アップロード完了",
    filterLabel: "オブジェクトを検索"
  },
  'zh-TW': {
     title: "智慧物品管理員",
    apiKeyPlaceholder: "請輸入您的 Gemini API 金鑰",
    captureButton: "拍攝照片並分析",
    rememberedObjects: "記住的物件",
    analyzing: "正在拍攝照片並分析...",
    apiKeyError: "請輸入您的 Gemini API 金鑰。",
    cameraError: "無法存取所選相機。請嘗試其他相機或檢查您的權限。",
    initError: "無法存取任何相機。請檢查您的設備和權限。",
    saveConfigButton: "儲存設定檔案",
    deleteConfirm: "您確定要刪除這個項目嗎？",
    editPrompt: "編輯物件：",
    customObjectPlaceholder: "輸入要記住的自定義物件...",
    addCustomObject: "新增物件",
    microphoneNotSupported: "此瀏覽器不支援語音辨識。",
    objectAdded: '物件新增成功！',
    deletePhotoConfirm: "您確定要刪除這張照片嗎？",
    uploadConfigButton: "從文件上傳配置",
    uploadInstruction: "請上傳一个包含您的對象配置的 JSON 文件。",
    filterPlaceholder: "篩選已記住的物件...",
    uploadFinished: "上傳完成",
    filterLabel: "搜尋物件"
  },
};
function filterObjects(searchText) {
  const normalizedSearch = searchText ? searchText.toLowerCase() : '';
  const filteredObjects = rememberedObjects.filter(obj => {
    const objectText = obj.text.toLowerCase();
    return normalizedSearch ? objectText.includes(normalizedSearch) : true;
  });
  objectMemory.innerHTML = filteredObjects.map((obj, index) => {
    const displayText = obj.text;
    return `
                    <div class="memory-item">
                        <div class="memory-controls">
                            <p>${displayText}</p>
                            <input type="text" 
                                class="memory-note" 
                                placeholder="Add a note..." 
                                value="${obj.note}"
                                id="note-${index}">
                            <button class="mic-button" id="mic-${index}"></button>
                            <button class="camera-button" onclick="captureObjectPhoto(${index})"></button>
                            <button class="edit-button" onclick="editMemory(${index})"></button>
                            <button class="clear-item-button" onclick="clearSingleMemory(${index})">✕</button>
                        </div>
                        ${obj.image ? `
                            <div class="photo-container">
                                <img src="${obj.image}" class="captured-photo" alt="Captured photo">
                                <button class="delete-photo-button" onclick="deleteObjectPhoto(${index})">🗑️ Delete photo</button>
                            </div>
                        ` : ''}
                         <div class="memory-item-buttons">
                            <button onclick="handleButtonClick(${index}, 'A1')">A1</button>
                            <button onclick="handleButtonClick(${index}, 'A2')">A2</button>
                            <button onclick="handleButtonClick(${index}, 'A3')">A3</button>
                            <button onclick="handleButtonClick(${index}, 'B1')">B1</button>
                            <button onclick="handleButtonClick(${index}, 'B2')">B2</button>
                            <button onclick="handleButtonClick(${index}, 'B3')">B3</button>
                        </div>
                    </div>
                `;
  }).join('');
  filteredObjects.forEach((_, index) => {
    const noteInput = document.getElementById(`note-${index}`);
    if (noteInput) {
      noteInput.addEventListener('input', () => {
        updateNote(index, noteInput.value);
      });
    }
    setupSpeechRecognition(index);
  });
}
function editMemory(index) {
  const item = rememberedObjects[index];
  const editDialog = document.createElement('div');
  editDialog.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 20px;
                border-radius: 10px;
                box-shadow: 0 0 10px rgba(0,0,0,0.2);
                z-index: 1001;
                width: 90%;
                max-width: 400px;
            `;
  editDialog.innerHTML = `
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="text" value="${item.text}" 
                        style="padding: 12px; border: 1px solid #ddd; border-radius: 4px; flex-grow: 1; font-size: 16px;">
                    <button class="mic-button" id="edit-mic" style="min-height: 44px; min-width: 44px;"></button>
                </div>
                <div style="margin-top: 15px; text-align: right;">
                    <button onclick="this.parentElement.parentElement.remove()" 
                        style="padding: 10px 20px; margin-right: 10px; background: #dc3545; color: white; border: none; border-radius: 4px; min-height: 44px;">
                        Cancel
                    </button>
                    <button onclick="saveEdit(${index}, this.parentElement.parentElement)" 
                        style="padding: 10px 20px; background: #4CAF50; color: white; border: none; border-radius: 4px; min-height: 44px;">
                        Save
                    </button>
                </div>
            `;
  document.body.appendChild(editDialog);
  const recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.lang = languageSelect.value;
  const micButton = editDialog.querySelector('#edit-mic');
  const inputField = editDialog.querySelector('input');
  let isRecording = false;
  micButton.addEventListener('click', () => {
    if (isRecording) {
      recognition.stop();
    } else {
      recognition.start();
    }
  });
  recognition.onstart = () => {
    isRecording = true;
    micButton.classList.add('recording');
  };
  recognition.onend = () => {
    isRecording = false;
    micButton.classList.remove('recording');
  };
  recognition.onresult = event => {
    const transcript = event.results[0][0].transcript;
    inputField.value = transcript;
  };
  const overlay = document.createElement('div');
  overlay.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 1000;
            `;
  document.body.appendChild(overlay);
  overlay.addEventListener('click', () => {
    overlay.remove();
    editDialog.remove();
  });
  inputField.focus();
  inputField.select();
}
function saveEdit(index, dialog) {
  let newText = dialog.querySelector('input').value.trim();
  newText = newText;
  if (newText !== '') {
    rememberedObjects[index].text = newText;
    localStorage.setItem('rememberedObjects', JSON.stringify(rememberedObjects));
    updateObjectMemory();
  }
  dialog.remove();
  document.querySelector('div[style*="background: rgba(0,0,0,0.5)"]')?.remove();
}
function setupSpeechRecognition(index) {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert(translations[languageSelect.value].microphoneNotSupported);
    return;
  }
  const recognition = new SpeechRecognition();
  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.lang = languageSelect.value;
  const micButton = document.getElementById(`mic-${index}`);
  let isRecording = false;
  recognition.onstart = () => {
    isRecording = true;
    micButton.classList.add('recording');
  };
  recognition.onend = () => {
    isRecording = false;
    micButton.classList.remove('recording');
  };
  recognition.onerror = event => {
    isRecording = false;
    micButton.classList.remove('recording');
    console.error('Speech recognition error:', event.error);
  };
  recognition.onresult = event => {
    const note = event.results[0][0].transcript;
    const noteInput = document.getElementById(`note-${index}`);
    noteInput.value = note;
    updateNote(index, note);
  };
  micButton.addEventListener('click', () => {
    if (isRecording) {
      recognition.stop();
    } else {
      document.querySelectorAll('.mic-button').forEach(button => {
        if (button.classList.contains('recording')) {
          button.classList.remove('recording');
        }
      });
      try {
        recognition.start();
      } catch (error) {
        console.error('Recognition start error:', error);
        isRecording = false;
        micButton.classList.remove('recording');
      }
    }
  });
  return recognition;
}
function setupCustomObjectSpeechRecognition() {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert(translations[languageSelect.value].microphoneNotSupported);
    return;
  }
  const recognition = new SpeechRecognition();
  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.lang = languageSelect.value;
  const micButton = document.getElementById('customObjectMic');
  const customInput = document.getElementById('customObjectInput');
  let isRecording = false;
  recognition.onstart = () => {
    isRecording = true;
    micButton.classList.add('recording');
  };
  recognition.onend = () => {
    isRecording = false;
    micButton.classList.remove('recording');
  };
  recognition.onerror = event => {
    isRecording = false;
    micButton.classList.remove('recording');
    console.error('Speech recognition error:', event.error);
  };
  recognition.onresult = event => {
    const transcript = event.results[0][0].transcript;
    customInput.value = transcript;
    filterObjects(transcript);
  };
  micButton.addEventListener('click', () => {
    if (isRecording) {
      recognition.stop();
    } else {
      document.querySelectorAll('.mic-button').forEach(button => {
        if (button.classList.contains('recording')) {
          button.classList.remove('recording');
        }
      });
      try {
        recognition.start();
      } catch (error) {
        console.error('Recognition start error:', error);
        isRecording = false;
        micButton.classList.remove('recording');
      }
    }
  });
}
function setupFilterSpeechRecognition() {
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    alert(translations[languageSelect.value].microphoneNotSupported);
    return;
  }
  const recognition = new SpeechRecognition();
  recognition.continuous = false;
  recognition.interimResults = false;
  recognition.lang = languageSelect.value;
  const micButton = document.getElementById('filterMic');
  const filterInput = document.getElementById('filterInput');
  let isRecording = false;
  recognition.onstart = () => {
    isRecording = true;
    micButton.classList.add('recording');
  };
  recognition.onend = () => {
    isRecording = false;
    micButton.classList.remove('recording');
  };
  recognition.onerror = event => {
    isRecording = false;
    micButton.classList.remove('recording');
    console.error('Speech recognition error:', event.error);
  };
  recognition.onresult = event => {
    const transcript = event.results[0][0].transcript;
    filterInput.value = transcript;
    filterObjects(transcript);
  };
  micButton.addEventListener('click', () => {
    if (isRecording) {
      recognition.stop();
    } else {
      document.querySelectorAll('.mic-button').forEach(button => {
        if (button.classList.contains('recording')) {
          button.classList.remove('recording');
        }
      });
      try {
        recognition.start();
      } catch (error) {
        console.error('Recognition start error:', error);
        isRecording = false;
        micButton.classList.remove('recording');
      }
    }
  });
}
function updateObjectMemory() {
  const currentLang = languageSelect.value;
  const searchText = filterInput.value.trim();
  const filteredObjects = rememberedObjects.filter(obj => {
    const objectText = obj.text.toLowerCase();
    return searchText ? objectText.includes(searchText.toLowerCase()) : true;
  });
  objectMemory.innerHTML = filteredObjects.map((obj, index) => {
    let displayText = obj.text;
    if (currentLang !== obj.lang) {
      if (objectTranslations[obj.originalText?.toLowerCase()]) {
        displayText = objectTranslations[obj.originalText.toLowerCase()][currentLang] || obj.text;
      } else {
        const words = (obj.originalText || obj.text).toLowerCase().split(' ');
        const translatedWords = words.map(word => {
          if (objectTranslations[word]) {
            return objectTranslations[word][currentLang] || word;
          }
          return word;
        });
        displayText = translatedWords.join(' ');
      }
    }
    return `
      <div class="memory-item">
        <div class="memory-controls">
          <p>${displayText}</p>
          <input type="text" 
              class="memory-note" 
              placeholder="Add a note..." 
              value="${obj.note}"
              id="note-${index}">
          <button class="mic-button" id="mic-${index}"></button>
          <button class="camera-button" onclick="captureObjectPhoto(${index})"></button>
          <button class="edit-button" onclick="editMemory(${index})"></button>
          <button class="clear-item-button" onclick="clearSingleMemory(${index})">✕</button>
        </div>
        ${obj.image ? `
          <div class="photo-container">
            <img src="${obj.image}" class="captured-photo" alt="Captured photo">
            <button class="delete-photo-button" onclick="deleteObjectPhoto(${index})">🗑️ Delete photo</button>
          </div>
        ` : ''}
           <div class="memory-item-buttons">
              <button onclick="handleButtonClick(${index}, 'A1')">A1</button>
              <button onclick="handleButtonClick(${index}, 'A2')">A2</button>
              <button onclick="handleButtonClick(${index}, 'A3')">A3</button>
              <button onclick="handleButtonClick(${index}, 'B1')">B1</button>
              <button onclick="handleButtonClick(${index}, 'B2')">B2</button>
              <button onclick="handleButtonClick(${index}, 'B3')">B3</button>
          </div>
      </div>
    `;
  }).join('');
  filteredObjects.forEach((obj, index) => {
    const noteInput = document.getElementById(`note-${index}`);
    if (noteInput) {
      noteInput.addEventListener('input', () => {
        updateNote(index, noteInput.value);
      });
    }
    setupSpeechRecognition(index);
  });
}
async function captureObjectPhoto(index) {
  const item = rememberedObjects[index];
  const modal = document.createElement('div');
  modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            `;
  const videoElement = document.createElement('video');
  videoElement.style.cssText = `
                width: 100%;
                max-width: 400px;
                margin-bottom: 20px;
            `;
  videoElement.autoplay = true;
  videoElement.playsinline = true;
  const buttonContainer = document.createElement('div');
  buttonContainer.style.cssText = `
                display: flex;
                gap: 10px;
            `;
  const captureBtn = document.createElement('button');
  captureBtn.textContent = '📸 Capture';
  captureBtn.style.cssText = `
                padding: 10px 20px;
                background: #4CAF50;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            `;
  const closeBtn = document.createElement('button');
  closeBtn.textContent = '✕ Close';
  closeBtn.style.cssText = `
                padding: 10px 20px;
                background: #dc3545;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
            `;
  buttonContainer.appendChild(captureBtn);
  buttonContainer.appendChild(closeBtn);
  modal.appendChild(videoElement);
  modal.appendChild(buttonContainer);
  document.body.appendChild(modal);
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        deviceId: cameraSelect.value ? {
          exact: cameraSelect.value
        } : undefined
      }
    });
    videoElement.srcObject = stream;
    closeBtn.onclick = () => {
      stream.getTracks().forEach(track => track.stop());
      modal.remove();
    };
    captureBtn.onclick = () => {
      const canvas = document.createElement('canvas');
      canvas.width = videoElement.videoWidth;
      canvas.height = videoElement.videoHeight;
      canvas.getContext('2d').drawImage(videoElement, 0, 0);
      rememberedObjects[index].image = canvas.toDataURL('image/jpeg');
      localStorage.setItem('rememberedObjects', JSON.stringify(rememberedObjects));
      updateObjectMemory();
      stream.getTracks().forEach(track => track.stop());
      modal.remove();
      const successMsg = document.createElement('div');
      successMsg.textContent = 'Photo captured successfully!';
      successMsg.style.cssText = `
                        position: fixed;
                        top: 20px;
                        left: 50%;
                        transform: translateX(-50%);
                        background: #4CAF50;
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 1001;
                    `;
      document.body.appendChild(successMsg);
      setTimeout(() => successMsg.remove(), 2000);
    };
  } catch (err) {
    console.error('Error accessing camera:', err);
    modal.innerHTML = `
                    <div style="color: white; padding: 20px; text-align: center;">
                        Error accessing camera. Please check your permissions.
                        <br><br>
                        <button onclick="this.parentElement.parentElement.remove()" 
                            style="padding: 10px 20px; background: white; color: black; border: none; border-radius: 5px; cursor: pointer;">
                            Close
                        </button>
                    </div>
                `;
  }
}
function clearSingleMemory(index) {
  const lang = languageSelect.value;
  const texts = translations[lang] || translations.en;
  if (confirm(texts.deleteConfirm)) {
    rememberedObjects.splice(index, 1);
    localStorage.setItem('rememberedObjects', JSON.stringify(rememberedObjects));
    updateObjectMemory();
  }
}
function deleteObjectPhoto(index) {
  const lang = languageSelect.value;
  const texts = translations[lang] || translations.en;
  if (confirm(texts.deletePhotoConfirm)) {
    rememberedObjects[index].image = null;
    localStorage.setItem('rememberedObjects', JSON.stringify(rememberedObjects));
    updateObjectMemory();
  }
}
function updateNote(index, note) {
  rememberedObjects[index].note = note;
  localStorage.setItem('rememberedObjects', JSON.stringify(rememberedObjects));
}
function updateLanguage(lang) {
  const texts = translations[lang] || translations.en;
  document.querySelector('h1').textContent = texts.title;
  apiKeyInput.placeholder = texts.apiKeyPlaceholder;
  captureButton.textContent = texts.captureButton;
  document.querySelector('h2#remembered-objects').textContent = texts.rememberedObjects;
  document.querySelector('h2.filter-label').textContent = texts.filterLabel || "Search Objects";
  document.getElementById('saveConfigButtonTop').textContent = texts.saveConfigButton;
  document.getElementById('saveConfigButtonBottom').textContent = texts.saveConfigButton;
  document.getElementById('customObjectInput').placeholder = texts.customObjectPlaceholder;
  document.getElementById('uploadConfigButton').textContent = texts.uploadConfigButton;
  uploadMessage.textContent = texts.uploadFinished;
  document.getElementById('filterInput').placeholder = texts.filterPlaceholder;
  document.getElementById('addObjectButton').textContent = texts.addCustomObject;
  updateObjectMemory();
  const micButtons = document.querySelectorAll(".mic-button");
  micButtons.forEach(button => {
    const id = button.id;
    if (id && id.startsWith("mic-")) {
      const index = parseInt(id.split("-")[1]);
      setupSpeechRecognition(index);
    }
  });
  setupCustomObjectSpeechRecognition();
  setupFilterSpeechRecognition();
}
async function populateCameraList() {
  try {
    const initialStream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: 'environment'
      }
    });
    initialStream.getTracks().forEach(track => track.stop());
    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoDevices = devices.filter(device => device.kind === 'videoinput');
    if (videoDevices.length === 0) {
      throw new Error('No cameras found');
    }
    cameraSelect.innerHTML = videoDevices.map(device => {
      const label = device.label || (device.deviceId.includes('back') || device.label.includes('back') ? 'Back Camera' : 'Front Camera');
      return `<option value="${device.deviceId}">${label}</option>`;
    }).join('');
    const backCamera = videoDevices.find(device => device.label.toLowerCase().includes('back') || device.deviceId.includes('back'));
    if (backCamera) {
      cameraSelect.value = backCamera.deviceId;
    }
    await startCamera(cameraSelect.value);
  } catch (err) {
    console.error('Error accessing camera:', err);
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: #ff4444;
                    color: white;
                    padding: 20px;
                    border-radius: 10px;
                    text-align: center;
                    z-index: 1000;
                    max-width: 80%;
                `;
    errorDiv.innerHTML = `
                    Camera access error:<br>
                    Please make sure you've granted camera permissions.<br><br>
                    <button onclick="retryCamera()" style="
                        padding: 10px 20px;
                        background: white;
                        color: black;
                        border: none;
                        border-radius: 5px;
                        cursor: pointer;
                    ">Retry Camera Access</button>
                `;
    document.body.appendChild(errorDiv);
  }
}
function retryCamera() {
  const errorDiv = document.querySelector('div[style*="position: fixed"]');
  if (errorDiv) {
    errorDiv.remove();
  }
  navigator.mediaDevices.getUserMedia({
    video: {
      facingMode: 'environment'
    }
  }).then(stream => {
    stream.getTracks().forEach(track => track.stop());
    populateCameraList();
  }).catch(err => {
    console.error("Error retrying camera:", err);
    populateCameraList();
  });
}
async function startCamera(deviceId) {
  const lang = languageSelect.value;
  const texts = translations[lang] || translations.en;
  if (currentStream) {
    currentStream.getTracks().forEach(track => track.stop());
  }
  const constraints = {
    video: {
      deviceId: deviceId ? {
        exact: deviceId
      } : undefined,
      facingMode: deviceId ? undefined : "environment",
      width: {
        ideal: 1280
      },
      height: {
        ideal: 720
      }
    }
  };
  try {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Camera access timeout')), 10000);
    });
    const stream = await Promise.race([navigator.mediaDevices.getUserMedia(constraints), timeoutPromise]);
    cameraFeed.srcObject = stream;
    currentStream = stream;
    cameraFeed.onplay = () => {
      console.log('Camera stream started successfully');
    };
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        const track = stream.getVideoTracks()[0];
        if (track) {
          const capabilities = track.getCapabilities();
          if (capabilities.width && capabilities.height) {
            track.applyConstraints({
              width: {
                ideal: window.innerWidth
              },
              height: {
                ideal: window.innerHeight
              }
            });
          }
        }
      }, 200);
    });
  } catch (err) {
    console.error("Error accessing camera:", err);
    const errorMessage = document.createElement('div');
    errorMessage.style.cssText = `
                    background: #ff4444;
                    color: white;
                    padding: 10px;
                    border-radius: 5px;
                    margin: 10px 0;
                    text-align: center;
                `;
    errorMessage.textContent = texts.cameraError;
    cameraFeed.parentElement.insertBefore(errorMessage, cameraFeed.nextSibling);
    setTimeout(() => errorMessage.remove(), 5000);
  }
}
async function captureAndAnalyze() {
  const lang = languageSelect.value;
  const texts = translations[lang] || translations.en;
  const apiKey = apiKeyInput.value.trim();
  if (!apiKey) {
    alert(texts.apiKeyError);
    return;
  }
  captureButton.disabled = true;
  spinner.style.display = 'block';
  analysisResult.textContent = texts.analyzing;
  const canvas = document.createElement('canvas');
  canvas.width = cameraFeed.videoWidth;
  canvas.height = cameraFeed.videoHeight;
  canvas.getContext('2d').drawImage(cameraFeed, 0, 0);
  capturedImage = canvas.toDataURL('image/jpeg').split(',')[1];
  try {
    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: `Analyze this image and describe what you see in ${languageSelect.options[languageSelect.selectedIndex].text}. Only provide the name of the main object and adjectives describing it. Do not include verbs, people, punctuations, body parts such as hands feet head, actions, or descriptions of movement. Put the adjectives in front of the object. Focus solely on the main object's name and their characteristics.`
          }, {
            inline_data: {
              mime_type: "image/jpeg",
              data: capturedImage
            }
          }]
        }]
      })
    });
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    const data = await response.json();
    if (data && data.candidates && data.candidates[0] && data.candidates[0].content && data.candidates[0].content.parts) {
      let mainObject = data.candidates[0].content.parts[0].text.trim().replace(/^(an?|the)\s+/i, '').replace(/\s+with\s+.*$/, '').replace(/\s+featuring\s+.*$/, '').replace(/\s+that\s+.*$/, '').replace(/\s+which\s+.*$/, '').replace(/\s+/g, ' ').trim();
      let translatedObject = mainObject;
      const targetLang = languageSelect.value;
      if (targetLang !== "en") {
        const words = mainObject.toLowerCase().split(" ");
        const translatedWords = words.map(word => {
          if (objectTranslations[word]) {
            return objectTranslations[word][targetLang] || word;
          }
          return word;
        });
        translatedObject = translatedWords.join(" ");
      }
      rememberedObjects.unshift({
        text: translatedObject,
        originalText: mainObject,
        note: "",
        lang: targetLang
      });
      localStorage.setItem("rememberedObjects", JSON.stringify(rememberedObjects));
      updateObjectMemory();
    }
  } catch (error) {
    console.error("Error:", error);
    analysisResult.textContent = "Error analyzing the image. Please check your API key and try again.";
  } finally {
    captureButton.disabled = false;
    spinner.style.display = "none";
  }
}
function saveConfigurationToFile() {
  const jsonData = {
    timestamp: new Date().toISOString(),
    objects: rememberedObjects
  };
  const jsonString = JSON.stringify(jsonData, null, 2);
  const blob = new Blob([jsonString], {
    type: "application/json"
  });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "camera-selector-objects.json";
  alert("Instructions to save the file:\n\n" + "1. A file download will begin\n" + "2. If you don't have one already, create a folder named 'Camera Selector with Gemini Analysis' in your C: drive\n" + "3. Save the file to C:\\Camera Selector with Gemini Analysis\\");
  a.click();
  URL.revokeObjectURL(url);
}
function uploadConfigurationFromFile() {
  const fileInput = document.getElementById("fileInput");
  const uploadButton = document.getElementById("uploadConfigButton");
  const uploadMessage = document.getElementById("uploadMessage");
  fileInput.removeEventListener("change", handleFileUpload);
  uploadButton.removeEventListener("click", triggerFileInput);
  function handleFileUpload(event) {
    if (event.target.files && event.target.files[0]) {
      const file = event.target.files[0];
      const reader = new FileReader();
      reader.onload = function (e) {
        try {
          const data = JSON.parse(e.target.result);
          if (data && data.objects) {
            rememberedObjects = [];
            localStorage.setItem("rememberedObjects", JSON.stringify(rememberedObjects));
            updateObjectMemory();
            rememberedObjects = data.objects;
            localStorage.setItem("rememberedObjects", JSON.stringify(rememberedObjects));
            updateObjectMemory();
            uploadMessage.style.display = "block";
            setTimeout(() => {
              uploadMessage.style.display = "none";
            }, 2000);
          } else {
            console.error("Invalid JSON format");
            alert("Invalid file format. Please upload a valid configuration file.");
          }
        } catch (error) {
          console.error("Error parsing JSON:", error);
          alert("Error reading file. Please make sure it's a valid JSON configuration file.");
        }
      };
      reader.onerror = function (error) {
        console.error("Error reading file:", error);
        alert("Error reading file. Please try again.");
      };
      reader.readAsText(file);
      fileInput.value = "";
    }
  }
  function triggerFileInput() {
    fileInput.click();
  }
  fileInput.addEventListener("change", handleFileUpload);
  uploadButton.addEventListener("click", triggerFileInput);
}
document.addEventListener("DOMContentLoaded", () => {
  setupCustomObjectSpeechRecognition();
  uploadConfigurationFromFile();
  updateLanguage(languageSelect.value);
  navigator.mediaDevices.getUserMedia({
    video: {
      facingMode: "environment",
      width: {
        ideal: 1280
      },
      height: {
        ideal: 720
      }
    }
  }).then(stream => {
    stream.getTracks().forEach(track => track.stop());
    populateCameraList();
  }).catch(err => {
    console.error("Error initializing camera:", err);
    populateCameraList();
  });
  filterInput.addEventListener('input', e => {
    const searchText = e.target.value.trim();
    filterObjects(searchText);
  });
  setupFilterSpeechRecognition();
});
captureButton.addEventListener("click", captureAndAnalyze);
document.getElementById("saveConfigButtonTop").addEventListener("click", saveConfigurationToFile);
document.getElementById("saveConfigButtonBottom").addEventListener("click", saveConfigurationToFile);
captureButton.addEventListener("click", captureAndAnalyze);
document.getElementById("saveConfigButtonTop").addEventListener("click", saveConfigurationToFile);
document.getElementById("saveConfigButtonBottom").addEventListener("click", saveConfigurationToFile);
cameraSelect.addEventListener("change", event => {
  startCamera(event.target.value);
});
languageSelect.addEventListener("change", event => {
  const newLang = event.target.value;
  updateLanguage(newLang);
  const micButtons = document.querySelectorAll(".mic-button");
  micButtons.forEach(button => {
    const id = button.id;
    if (id && id.startsWith("mic-")) {
      const index = parseInt(id.split("-")[1]);
      setupSpeechRecognition(index);
    }
  });
  setupCustomObjectSpeechRecognition();
  setupFilterSpeechRecognition();
});
document.getElementById("addObjectButton").addEventListener("click", () => {
  const customInput = document.getElementById("customObjectInput");
  let customText = customInput.value.trim().replace(/^(an?|the)\s+/i, '').replace(/\s+with\s+.*$/, '').replace(/\s+featuring\s+.*$/, '').replace(/\s+that\s+.*$/, '').replace(/\s+which\s+.*$/, '').replace(/\s+/g, ' ').trim();
  if (!customText) {
    alert("Please enter an object name first");
    return;
  }
  rememberedObjects.unshift({
    text: customText,
    note: "",
    lang: languageSelect.value
  });
  localStorage.setItem("rememberedObjects", JSON.stringify(rememberedObjects));
  updateObjectMemory();
  customInput.value = "";
  const successMessage = document.createElement("div");
  successMessage.textContent = translations[languageSelect.value].objectAdded || "Object added successfully!";
  successMessage.style.cssText = `
                        color: green;
                        margin-top: 5px;
                        font-size: 14px;
                    `;
  customInput.parentElement.appendChild(successMessage);
  setTimeout(() => successMessage.remove(), 2000);
});
document.getElementById("customObjectInput").addEventListener("keypress", e => {
  if (e.key === "Enter") {
    document.getElementById("addObjectButton").click();
  }
});
document.getElementById("customObjectInput").addEventListener("input", e => {
  const searchText = e.target.value.trim();
  if (searchText) {
    filterObjects(searchText);
  } else {
    filterObjects();
  }
});
updateLanguage("en");
updateObjectMemory();
function updateLanguage(lang) {
  const texts = translations[lang] || translations.en;
  document.querySelector('h1').textContent = texts.title;
  apiKeyInput.placeholder = texts.apiKeyPlaceholder;
  captureButton.textContent = texts.captureButton;
  document.querySelector('h2#remembered-objects').textContent = texts.rememberedObjects;
  document.querySelector('h2.filter-label').textContent = texts.filterLabel || "Search Objects";
  document.getElementById('saveConfigButtonTop').textContent = texts.saveConfigButton;
  document.getElementById('saveConfigButtonBottom').textContent = texts.saveConfigButton;
  document.getElementById('customObjectInput').placeholder = texts.customObjectPlaceholder;
  document.getElementById('uploadConfigButton').textContent = texts.uploadConfigButton;
  uploadMessage.textContent = texts.uploadFinished;
  document.getElementById('filterInput').placeholder = texts.filterPlaceholder;
  document.getElementById('addObjectButton').textContent = texts.addCustomObject;
  updateObjectMemory();
  const micButtons = document.querySelectorAll(".mic-button");
  micButtons.forEach(button => {
    const id = button.id;
    if (id && id.startsWith("mic-")) {
      const index = parseInt(id.split("-")[1]);
      setupSpeechRecognition(index);
    }
  });
  setupCustomObjectSpeechRecognition();
  setupFilterSpeechRecognition();
}
updateLanguage("en");
updateObjectMemory();
function updateLanguage(lang) {
  const texts = translations[lang] || translations.en;
  document.querySelector('h1').textContent = texts.title;
  apiKeyInput.placeholder = texts.apiKeyPlaceholder;
  captureButton.textContent = texts.captureButton;
  document.querySelector('h2#remembered-objects').textContent = texts.rememberedObjects;
  document.querySelector('h2.filter-label').textContent = texts.filterLabel || "Search Objects";
  document.getElementById('saveConfigButtonTop').textContent = texts.saveConfigButton;
  document.getElementById('saveConfigButtonBottom').textContent = texts.saveConfigButton;
  document.getElementById('customObjectInput').placeholder = texts.customObjectPlaceholder;
  document.getElementById('uploadConfigButton').textContent = texts.uploadConfigButton;
  uploadMessage.textContent = texts.uploadFinished;
  document.getElementById('filterInput').placeholder = texts.filterPlaceholder;
  document.getElementById('addObjectButton').textContent = texts.addCustomObject;
  updateObjectMemory();
  const micButtons = document.querySelectorAll(".mic-button");
  micButtons.forEach(button => {
    const id = button.id;
    if (id && id.startsWith("mic-")) {
      const index = parseInt(id.split("-")[1]);
      setupSpeechRecognition(index);
    }
  });
  setupCustomObjectSpeechRecognition();
  setupFilterSpeechRecognition();
}
function handleButtonClick(index, buttonId) {
  console.log(`Button ${buttonId} clicked for object at index ${index}`);
  const item = rememberedObjects[index];
  if (item) {
    console.log("Object: ", item);
    rememberedObjects[index].text = rememberedObjects[index].text.replace(/, [A-B][1-3]$/, '');
    rememberedObjects[index].text = rememberedObjects[index].text + `, ${buttonId.toUpperCase()}`; // 強制轉為大寫
    localStorage.setItem('rememberedObjects', JSON.stringify(rememberedObjects));
    updateObjectMemory();
  }
}
</script>
</body></html>
